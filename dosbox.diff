Index: src/gui/sdl_mapper.cpp
===================================================================
--- src/gui/sdl_mapper.cpp	(revision 3840)
+++ src/gui/sdl_mapper.cpp	(working copy)
@@ -359,8 +359,12 @@
    expression will raise a compiler error if the condition is false.  */
 typedef char assert_right_size [MAX_SCANCODES == (sizeof(sdlkey_map)/sizeof(sdlkey_map[0]))	? 1 : -1];
 
-#else // !MACOSX
+#elif defined(__native_client__)
 
+extern SDLKey sdlkey_map[MAX_SCANCODES];
+
+#else // !MACOSX && !__native_client__
+
 #define MAX_SCANCODES 212
 static SDLKey sdlkey_map[MAX_SCANCODES]={SDLK_UNKNOWN,SDLK_ESCAPE,
 	SDLK_1,SDLK_2,SDLK_3,SDLK_4,SDLK_5,SDLK_6,SDLK_7,SDLK_8,SDLK_9,SDLK_0,
@@ -414,7 +418,8 @@
 			/* try to retrieve key from symbolic key as scancode is zero */
 			if (keysym.sym<MAX_SDLKEYS) key=scancode_map[(Bitu)keysym.sym];
 		} 
-#if !defined (WIN32) && !defined (MACOSX) && !defined(OS2)
+#if !defined (WIN32) && !defined (MACOSX) && !defined(OS2) && \
+		!defined(__native_client__)
 		/* Linux adds 8 to all scancodes */
 		else key-=8;
 #endif
@@ -2407,7 +2412,7 @@
 		usescancodes=true;
 
 		/* Note: table has to be tested/updated for various OSs */
-#if defined (MACOSX)
+#if defined (MACOSX) || defined(__native_client__)
 		/* nothing */
 #elif defined(OS2)
 		sdlkey_map[0x61]=SDLK_UP;
Index: src/gui/sdlmain.cpp
===================================================================
--- src/gui/sdlmain.cpp	(revision 3840)
+++ src/gui/sdlmain.cpp	(working copy)
@@ -1817,9 +1817,13 @@
 	exit(0);
 }
 
+int ChromeAppInit(int* argc_ptr, char** argv_ptr[]);
 
 //extern void UI_Init(void);
 int main(int argc, char* argv[]) {
+	if (ChromeAppInit(&argc, &argv))
+		return 1;
+
 	try {
 		CommandLine com_line(argc,argv);
 		Config myconf(&com_line);
@@ -1899,7 +1903,10 @@
 	 */
 	putenv(const_cast<char*>("SDL_DISABLE_LOCK_KEYS=1"));
 #endif
-	if ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_CDROM
+	if ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO|SDL_INIT_TIMER
+#ifndef __native_client__
+		|SDL_INIT_CDROM
+#endif
 		|SDL_INIT_NOPARACHUTE
 		) < 0 ) E_Exit("Can't init SDL %s",SDL_GetError());
 	sdl.inited = true;
Index: src/cpu/core_dyn_x86/risc_x86.h
===================================================================
--- src/cpu/core_dyn_x86/risc_x86.h	(revision 3840)
+++ src/cpu/core_dyn_x86/risc_x86.h	(working copy)
@@ -133,7 +133,11 @@
 		"pushl %%ebp						\n"
 		"pushl $(run_return_adress)			\n"
 		"pushl  %2							\n"
+#ifndef __native_client__
 		"jmp  *%3							\n"
+#else
+		"nacljmp  %3							\n"
+#endif
 		"run_return_adress:					\n"
 		"popl %%ebp							\n"
 		:"=a" (retval), "=c" (tempflags)
Index: src/cpu/cpu.cpp
===================================================================
--- src/cpu/cpu.cpp	(revision 3840)
+++ src/cpu/cpu.cpp	(working copy)
@@ -22,7 +22,9 @@
 #include <stddef.h>
 #include "dosbox.h"
 #include "cpu.h"
-#include "memory.h"
+#ifndef __native_client__
+#  include "memory.h"
+#endif
 #include "debug.h"
 #include "mapper.h"
 #include "setup.h"
Index: src/ints/bios.cpp
===================================================================
--- src/ints/bios.cpp	(revision 3840)
+++ src/ints/bios.cpp	(working copy)
@@ -490,11 +490,10 @@
 
 static void BIOS_HostTimeSync() {
 	/* Setup time and date */
-	struct timeb timebuffer;
-	ftime(&timebuffer);
-	
+	time_t curtime;
 	struct tm *loctime;
-	loctime = localtime (&timebuffer.time);
+	curtime = time (NULL);
+	loctime = localtime (&curtime);
 
 	/*
 	loctime->tm_hour = 23;
@@ -512,8 +511,8 @@
 	Bit32u ticks=(Bit32u)(((double)(
 		loctime->tm_hour*3600*1000+
 		loctime->tm_min*60*1000+
-		loctime->tm_sec*1000+
-		timebuffer.millitm))*(((double)PIT_TICK_RATE/65536.0)/1000.0));
+		loctime->tm_sec*1000
+		))*(((double)PIT_TICK_RATE/65536.0)/1000.0));
 	mem_writed(BIOS_TIMER,ticks);
 }
 
